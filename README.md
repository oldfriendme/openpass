
# openpass

> 越复杂的系统往往只需要最简单取巧的方式 --- 张三

<br>

**openpass** 是一个极简、超高速的字节位移实现，重拾了几千年前 凯撒大帝 的智慧实现，流量转发性能接近 `raw TCP` 链接速度，实现代码不到160行，可以让大量低端DPI变成瞎子。

---

<br>

## 原理
凯撒加密虽然只要遍历n次就能破解，但是大部分流量工具并没有这种能力。并且其内存与buf，不可能大量链接流量的遍历所有的凯撒位移。

> [!IMPORTANT]  
> 注意：如果要反驳该实现的实用性，请使用详细的代码实现来反驳，**Talk is cheap. Show me the code**。而不仅仅是从理论上指出。（另外，如果真的实现了，我会更新新逻辑的）
> 
> 距现在为止，其能让[opengfw](https://github.com/apernet/OpenGFW)的所有规则分析模式失效，让其退化为只能src/dec的分析（类似iptables）

----

<br>

## 特点

- **双端协作**：分为服务端与客户端，端到端凯撒位移。
- **极低延迟**：只进行字节的简单位移处理，几乎不影响吞吐量。
- **流式加密**：按数据流进行实时位移，不需缓存整块数据。内存占用极低。
- **抗传统 DPI**：很多 DPI 无法高效遍历所有位移，也无法判断流量是否被凯撒加密，从而无法分析原文。
- **易于部署**：轻量化代码，无复杂依赖。

---

<br>

## 工作流程

1. **客户端**：
   - 接收到应用层或网络层的数据流。
   - 将流中的每个字节按设定位移量进行加密处理（凯撒位移）。
   - 将凯撒位移后的数据发送到服务端。

2. **服务端**：
   - 接收加密数据流。
   - 按相同位移量反向位移解密。
   - 将凯撒位移后数据转发或处理。

凯撒加密算法的运算极为简单高效，**openpass** 在大部分场景下的性能几乎等同于未经加密的 TCP。

<br>

## 流量路径对比

### 1.原始路径
```
[ssh Client] ---> [ssh Server]
   |                         |
   +---- ssh握手可被 DPI 读取 ----+
```

DPI 可以直接读取握手包中的信息。

<br>

### 2.使用 openpass 后

```
[ssh Client]
      |
      v
[openpass-client] --(凯撒位移加密的TCP流)--> [openpass-server]
      |                                                 |
      +-------------- 原始ssh流量复原 -------------------+
                                                        |
                                                    [ssh Server]
```

<br>

### 3.对于tls流量，也是同理。

```
[TLS Client]
      |
      v
[openpass-client] --(凯撒位移加密的TCP流)--> [openpass-server]
      |                                                 |
      +-------------- 原始TLS流量复原 -------------------+
                                                        |
                                                    [TLS Server]
```

<br>

### 4.任何协议都可以使用openpass承载，并且openpass对于[opengfw](https://github.com/apernet/OpenGFW)的绕过特别有效

```
[Any Protocol]
      |
      v                  opengfw(失明)
[openpass-client] --(凯撒位移加密的TCP流)--> [openpass-server]
      |                                                 |
      +-------------- 原始Protocol流量复原 -------------------+
                                                        |
                                                    [Protocol Server]
```

不信你就试试。

<br>

### 凯撒位移加密的TCP流，虽然看上去很简单，但是却由于原文的不确定，很难以固定简单模式匹配。


<br>

## 为什么使用凯撒加密这种古老的算法。

因为简单啊，你想想，直接使用最简单的方法，直接击破的各种复杂的DPI设备，这本来就很geek.


<br>

## 为什么流量分析变成瞎子

传统或廉价 DPI 设备的特点：
- 需要在给每条tcp有限的内存与缓冲区的分配数据内容进行模式匹配。并且没有硬件加速。
- 遍历所有可能的凯撒位移成本高昂，尤其是高速流量下。只能基于现有模式（特定偏移量,特定字段）匹配。
- 如果原文无明显模式（尤其是二进制协议或非自然语言），更难区分是否为凯撒位移。

在这种情况下，无法确认偏移量，也无法识别原文，从而“变成瞎子”。




<br>

## 使用示例

#### 1.服务端启动，位移123位
```bash
openpass server 0.0.0.0:9000 127.0.0.1:80 123
```

#### 2.客户端启动
```bash
openpass client yourserver.com:9000 127.0.0.1:8888 123
```

 >`123` 为凯撒位移量，客户端与服务端需一致。可以填写任意大于0的整数

**客户端连接本地的127.0.0.1:8888，这个端口即转发到服务端127.0.0.1:80**




<br>

## 性能测试

在千兆链路测试下，openpass 的转发速度仅比原始 TCP 吞吐低约 0.1%~0.5%，延迟差异几乎不可感知。



<br>

## 注意事项

- 凯撒位移并 **不是** 加密算法，没有aead检验，只是能绕过实时DPI工具，请在内层使用加密算法，单纯使用不能保护隐私数据。
- openpass的特征基于内层数据特征，如果内层数据有频率特征，外层会有一样的特征。openpass并无明显的外层频率统计特征。

<br>

## License
本实现基于apache2.0许可证发布，请遵循apache2.0的条款，特别是"AS IS"。
